/// Rust对于每一个值，都有一个生命周期与之对应，值参与的作用域越大，生命周期越大。
/// 对于如何判断生命周期不再可用，或者生命周期范围覆盖失败，Rust使用"引用检查器"的机制进行分析。
/// 生命周期问题一般存在于函数调用中，同一个函数的生命周期一般遵循书写顺序，但是函数调用的返回值的生命周期则需要我们细细考量。
/// 在Rust中天然存在三种可以推断出来的生命周期，除了这三种规则适用的情况外，其他的情况均需要我们手动制定值的生命周期。
fn note() {
}

struct Tmp<'a, T> {
    // 结构体字段的生命周期 >= 结构体对象的生命周期
    x: &'a T,
}

pub fn test_lifetime() {
    let res1;
    let s1 = String::from("abc");
    {
        let s2 = String::from("abcd");
        res1 = choose_longest_str(s1.as_str(), s2.as_str());
        println!("{}", res1)
    }
    // 如果在这里打印res1则会失败，因为res1的生命周期为s2的生命周期，所以会出错
    // println!("{}", res1)
    // 这段代码报错的原因依旧是生命周期问题，因为字段生命周期小于对象生命周期
    // let t;
    // {
    //     t = Tmp {
    //         x: &String::from("aaa"),
    //     };
    // }
    // println!("{}", t.x)

    // 一个全局生命周期的例子，它会和程序共生死
    let all: &'static str = "static";
}

/// 这个函数编译失败的原因就是因为Rust不知道返回值的生命周期到底依赖于哪一个入参
// fn choose_longest_str_err(s1: &str, s2: &str) -> &str {
//     if s1.len() > s2.len() {
//         s1
//     } else {
//         s2
//     }
// }

/// 生命周期语法: '加一个变量，一般是'a, 'b之类的，本质是一个占位符，表示和它关联的值的生命周期。
// 这里通过生命周期语法'a来指出返回值的生命周期和s1或s2中的生命周期最小的那个一致。
// 这里为什么是最小的呢？因为s1和s2的生命周期都是'a表示，返回值的生命周期也是'a，说明返回值的生命周期
// 和s1或s2一致，那肯定就要以最小的为准，否则会出现问题。
// 如果不好理解，可以理解s1生命周期为'a，s2为'b，则返回值为min('a, 'b)。只是均使用'a时表示这样的效果。
fn choose_longest_str<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s1.len() > s2.len() {
        s1
    } else {
        s2
    }
}

/// 第一条规则：每个函数参数都有自己的生命周期参数。
fn rule_one<'a, 'b, 'c>(x: &'a i32, y: &'b String, z: &'c str) {
}

/// 第二条规则：如果只有一个输入参数，那么它的生命周期就是输出参数(返回值)的生命周期。
fn rule_two<'a, T>(x: &'a T) -> &T {
    x
}

/// 第三条规则：方法的返回值的生命周期和方法接受者的生命周期一致
impl<'a, T> Tmp<'a, T> {
    fn rule_three(&self) -> &T {
        self.x
    }
}